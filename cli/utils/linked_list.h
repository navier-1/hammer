/**
 * Doubly linked list implementation.
 * Provides support for array-like operations and for polimorphism.
 * 
 * // TODO: could allow for head and tail to match and have a looping list
 */
#pragma once
#include <stddef.h>

typedef struct node node_t;

struct node {
    void* value;
    node_t* next;
    node_t* prev;
};

typedef struct list {
    unsigned len;
    node_t* head;
    node_t* tail;
} list_t;


list_t* initList(void);
list_t* initListFromStringArray(char** arr, size_t len);

/**
 * Prints out the formatted values in the linked list. Useful for debugging.
 * examples:
 * 
 *  printList(list, "%d"); // list of integers
 *  printList(list, "%s"); // list of strings
 *  printList(list, "%f"); // list of floats
 *  printList(list, "%ff"); // list of doubles (a bit hacky)
 *
 *  // some formatted prints 
 *  printList(list, "[%d]");
 *  printList(list, " ~~ %s ~~ ");
 */
void printList(const list_t* list, const char* fmt);

/**
 * Append new data to the linked list. *Be careful with the elem_size when appending strings*
 * 
 * - default append() will simply store the pointer to the data passed in. It is up to the user
 *   to keep track of the type and how that data is used.
 * 
 * - appendCopy() will memcpy() that memory into a node, so the user can subsequently free that memory.
 */
int append(list_t* list, void* elem);
int appendCopy(list_t* list, void* elem, size_t elem_size);

/**
 * Frees the memory for all the node_t structs internally allocated.
 * 
 * If the data with which the list was populated was heap-allocated and owned by the list,
 * set free_values to any non-zero value to free the data, too.
 */
void freeList(list_t** list, int free_values);


/**
 * Returns the pointer to the value of the i-th node if it exists, NULL otherwise.
 */
void* getValue(const list_t* list, size_t i);

/**
 * Small utility methods to handle head and tail.
 */
extern node_t* getHeadNode(const list_t* list);
extern node_t* getTailNode(const list_t* list);

extern void setHeadNode(list_t* list, node_t* node);
extern void setTailNode(list_t* list, node_t* node);

extern void* getHeadValue(const list_t* list);
extern void* getTailValue(const list_t* list);



/**
 * Copies the pointer 'value' to the i-th node in the list.
 * Returns 0 on success
 */
int setValue(list_t* list, size_t i, void* value);

/**
 * Removes the given node from the list it belongs to.
 * 
 * If free_value is set to 1, the value is assumed to be heap allocated and freed,
 * then the node itself is freed.
 * 
 * Otherwise, only the node struct is freed.
 * 
 * If the user is unlinking a node that was generated by doing appendCopy() then they should also free the memory;
 * if the node was simply pointer support around memory which does not belong to the list, but rather to some list
 * which exists out in the wild they should *not* free it; the node_t that wrapped that data will still be freed.
 */
int unlink(node_t* node, int free_value);



// int insert(list_t* list, void* value, size_t index);

